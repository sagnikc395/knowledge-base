---
title: Javascript Fundamentals
tags:
  - projects
  - javascript
  - 100xdevs
date: 1/13/25
---
- course notes for 100xDev Javascript Fundamentals.
-  why languages ?
	- computer has ram and storage.
	- whenever we have application locally resides in the SSD
	- when we run something -- it runs in RAM
	- the current things in RAM, other things in SSD 
	- what exactly goes to RAM? Some hardware and circuits - machine at the lowest level only understands a bunch of numbers 
	- RAM doesnt understand programming languages -> represented by 0s and 1s.
	- Using something called compilers -> high level code , compiled to 0s and 1s. by the compiler. Much easier to run for loops, 0s and 1s. High level need of a programming language.
	- Every language has a compiler which convers the developer code into binary.
	- Compilers -> converts high level developer code into binary
- Interpreted vs compiled languages 
	- C++ is compiled -> compiles the code into binary by the compiler
	- JS is interpreted directly. No specific compilation step
	- Goes line by line ; doesn't worry about high level compilation of the whole thing
		-  usually goes line by line 
		- can run partially if the error comes later
- why JS >> Other languages in some use-cases
	- browsers can only understand HTML/CSS/JS.
	- Due to Node.js , Javascript can also be used for "Backend Development".
	- Javascript is loosely typed and it allows us to changes the types of the variables.
	- Project might have runtime errors -> leads to use of Typescript.
		- makes js more static -> same things that we see here, added into Javascript.
	- Strict vs Dynamic Languages
- Single Threaded nature of JS 
	- JS is a single threaded language.
	- the number of cores -> one of the specs of a new machine.
	- one single core -> run code at a single time.
	- the more the number of cores that we have, the more the number of processes that we can run.
	- there is something called context switching -> not everything needs the RAM right now.
	- It is some place that can run some code at the single time.
	- Cannot run parallely.
	- JS is always restricted to a single core.
		- cannot split our program to 2 cores , to split your loads and reduce load -> making it more optimal.
		- This is why it is considered to be a bad language for scalable systems.
		- Practically, JS runs line by line and only one line runs at a time. Go lets your create goroutines, JS doesn't.
- Simple Primitives in JS(number, strings, booleans)
	- covered in the repo.
- Complex Primitives in JS(arrays, objects)
	- arrays -> storage items of the same / different types.
	- objects -> key/value pairs of items and custom values.
	- arrays dont have to be of objects and can be of differnt types mixed together.
- Functions in JS
	- lets us abstract out logic in our program.
	- take arguments in an input
	- return a value as an output
	- can think of them as an independent program that is supposed to do something given an input.
	- functions can take other functions as input -> callbacks.
- Callback functions, event loop, callback queue, asynchronous programming 
	- callback functions -> function take other functions as inputs 
	- can change what function to get called, changed and pass the function as an argument.
	- passing a functions as an arguments.
	- inside the function, we are calling back some other functions 
	- that's why its named as call back function.
	- Eg: setTimeout -> takes a function and calling it after sometime is a callback
	- Single Threaded -> only one thread available for the runtime to use 
	- Non blocking call -> if we make an expensive network call / db call -> it will defer the call until the thread is free to do the execution.
- Callback Hell and Promises
- Basic JS APIs
	- JS refresher and practice for JS.
- Classes 
	- to abstract away repeated logic to keep an instance of an object 
	- can add properties and methods on the instance
	- giving a structure that is reusable and used in multiple places.
	- define a blueprint of each item of that class.
	- can also have static functions on class 
		- not associated to an object
		- associated with the blueprint itself.
		- can be called without instantiating a object.
- Date Class
	- global date class given by JS.
	- present to use out of the box.
- JSON
	- Javascript Object Notation.
	- `JSON.parse()` to extract the string into a valid JSON object
	- `JSON.stringify()` to encode the object into a string.
	- interchange bw strings and json using this 
	- use case: when we get data from a server when we need to encode and decode the data -> stringify a data into a string , and while interacting with it , turn in back into object.
- Math 
	- `Math.random()` -> gives a random number bw 0 and 1 
	- `Math.floor()`
	- `Math.ceil()`
	- `Math.max()`
	- `Math.min()`
- Objects
	- can set , unset properties on objects.
	- get the original object -> `obj` 
	- get all the keys of the object -> `Object.keys(obj)`
	- get all the values of the object -> `Object.values(obj)`
	- get all the entries of the object -> `Object.entries(obj)` (key-value pairs)
	- check if the property of the object is its own or from parent node -> `obj.hasOwnProperty("property-name")`
	- assign a new key and value to the object -> `Object.assign({},obj,{newProperty: "newValue"})`
