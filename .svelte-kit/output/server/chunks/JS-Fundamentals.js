import { G as sanitize_props, J as spread_props } from "./index.js";
import { M as MarkdownLayout } from "./MarkdownLayout.js";
const metadata = {
  "title": "Javascript Fundamentals",
  "tags": ["projects", "javascript", "100xdevs"],
  "date": "1/19/26"
};
const { title, tags, date } = metadata;
function JS_Fundamentals_md($$renderer, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  MarkdownLayout($$renderer, spread_props([
    $$sanitized_props,
    metadata,
    {
      children: ($$renderer2) => {
        $$renderer2.push(`<h3>course notes for 100xDev Javascript Fundamentals.</h3> <ul><li><p>why languages ?</p> <ul><li>computer has ram and storage.</li> <li>whenever we have application locally resides in the SSD</li> <li>when we run something — it runs in RAM</li> <li>the current things in RAM, other things in SSD</li> <li>what exactly goes to RAM? Some hardware and circuits - machine at the lowest level only understands a bunch of numbers</li> <li>RAM doesnt understand programming languages -> represented by 0s and 1s.</li> <li>Using something called compilers -> high level code , compiled to 0s and 1s. by the compiler. Much easier to run for loops, 0s and 1s. High level need of a programming language.</li> <li>Every language has a compiler which convers the developer code into binary.</li> <li>Compilers -> converts high level developer code into binary</li></ul></li> <li><p>Interpreted vs compiled languages</p> <ul><li>C++ is compiled -> compiles the code into binary by the compiler</li> <li>JS is interpreted directly. No specific compilation step</li> <li>Goes line by line ; doesn’t worry about high level compilation of the whole thing <ul><li>usually goes line by line</li> <li>can run partially if the error comes later</li></ul></li></ul></li> <li><p>why JS >> Other languages in some use-cases</p> <ul><li>browsers can only understand HTML/CSS/JS.</li> <li>Due to Node.js , Javascript can also be used for “Backend Development”.</li> <li>Javascript is loosely typed and it allows us to changes the types of the variables.</li> <li>Project might have runtime errors -> leads to use of Typescript. <ul><li>makes js more static -> same things that we see here, added into Javascript.</li></ul></li> <li>Strict vs Dynamic Languages</li></ul></li> <li><p>Single Threaded nature of JS</p> <ul><li>JS is a single threaded language.</li> <li>the number of cores -> one of the specs of a new machine.</li> <li>one single core -> run code at a single time.</li> <li>the more the number of cores that we have, the more the number of processes that we can run.</li> <li>there is something called context switching -> not everything needs the RAM right now.</li> <li>It is some place that can run some code at the single time.</li> <li>Cannot run parallely.</li> <li>JS is always restricted to a single core. <ul><li>cannot split our program to 2 cores , to split your loads and reduce load -> making it more optimal.</li> <li>This is why it is considered to be a bad language for scalable systems.</li> <li>Practically, JS runs line by line and only one line runs at a time. Go lets your create goroutines, JS doesn’t.</li></ul></li></ul></li> <li><p>Simple Primitives in JS(number, strings, booleans)</p> <ul><li>covered in the repo.</li></ul></li> <li><p>Complex Primitives in JS(arrays, objects)</p> <ul><li>arrays -> storage items of the same / different types.</li> <li>objects -> key/value pairs of items and custom values.</li> <li>arrays dont have to be of objects and can be of differnt types mixed together.</li></ul></li> <li><p>Functions in JS</p> <ul><li>lets us abstract out logic in our program.</li> <li>take arguments in an input</li> <li>return a value as an output</li> <li>can think of them as an independent program that is supposed to do something given an input.</li> <li>functions can take other functions as input -> callbacks.</li></ul></li> <li><p>Callback functions, event loop, callback queue, asynchronous programming</p> <ul><li>callback functions -> function take other functions as inputs</li> <li>can change what function to get called, changed and pass the function as an argument.</li> <li>passing a functions as an arguments.</li> <li>inside the function, we are calling back some other functions</li> <li>that’s why its named as call back function.</li> <li>Eg: setTimeout -> takes a function and calling it after sometime is a callback</li> <li>Single Threaded -> only one thread available for the runtime to use</li> <li>Non blocking call -> if we make an expensive network call / db call -> it will defer the call until the thread is free to do the execution.</li></ul></li> <li><p>Callback Hell and Promises</p></li> <li><p>Basic JS APIs</p> <ul><li>JS refresher and practice for JS.</li></ul></li> <li><p>Classes</p> <ul><li>to abstract away repeated logic to keep an instance of an object</li> <li>can add properties and methods on the instance</li> <li>giving a structure that is reusable and used in multiple places.</li> <li>define a blueprint of each item of that class.</li> <li>can also have static functions on class <ul><li>not associated to an object</li> <li>associated with the blueprint itself.</li> <li>can be called without instantiating a object.</li></ul></li></ul></li> <li><p>Date Class</p> <ul><li>global date class given by JS.</li> <li>present to use out of the box.</li></ul></li> <li><p>JSON</p> <ul><li>Javascript Object Notation.</li> <li><code>JSON.parse()</code> to extract the string into a valid JSON object</li> <li><code>JSON.stringify()</code> to encode the object into a string.</li> <li>interchange bw strings and json using this</li> <li>use case: when we get data from a server when we need to encode and decode the data -> stringify a data into a string , and while interacting with it , turn in back into object.</li></ul></li> <li><p>Math</p> <ul><li><code>Math.random()</code> -> gives a random number bw 0 and 1</li> <li><code>Math.floor()</code></li> <li><code>Math.ceil()</code></li> <li><code>Math.max()</code></li> <li><code>Math.min()</code></li></ul></li> <li><p>Objects</p> <ul><li>can set , unset properties on objects.</li> <li>get the original object -> <code>obj</code></li> <li>get all the keys of the object -> <code>Object.keys(obj)</code></li> <li>get all the values of the object -> <code>Object.values(obj)</code></li> <li>get all the entries of the object -> <code>Object.entries(obj)</code> (key-value pairs)</li> <li>check if the property of the object is its own or from parent node -> <code>obj.hasOwnProperty("property-name")</code></li> <li>assign a new key and value to the object -> <code>Object.assign({},obj,{newProperty: "newValue"})</code></li></ul></li> <li><p>Async functions vs Sync Functions</p> <ul><li>what does synchronous mean ? <ul><li>together, one after the other or sequential</li> <li>only one things is happening at a time</li> <li>async -> opposite of async <ul><li>happens in parts</li> <li>multiple things are context switching with each other</li></ul></li> <li>eg: human body and brain is single threaded; we can only do one thing at a time -> but we can context switch b/w tasks , or we can delegaet tasks to other people.</li></ul></li> <li>async functions <ul><li>eg: filesystem access in nodejs</li> <li>net amount of time take to do a task can be decreased using async functions (delegating and context switching)</li></ul></li> <li>setTimeout is like a global async function that JS provides that we can use it to check it.</li> <li>part of the browser api , very common use</li> <li>running a specific function after a duration (in ms)</li></ul> <pre class="shiki vesper" style="background-color:#101010;color:#FFF"><code><span class="line"><span style="color:#FFC799">setTimeout</span><span style="color:#FFF">(() </span><span style="color:#A0A0A0">=></span><span style="color:#FFF"> {</span></span>
<span class="line"><span style="color:#FFF">	console.</span><span style="color:#FFC799">log</span><span style="color:#FFF">(</span><span style="color:#99FFE4">"ok"</span><span style="color:#FFF">)},</span><span style="color:#FFC799">1000</span></span>
<span class="line"><span style="color:#FFF">);</span></span></code></pre> <ul><li>one way to make an async function synchronous is to use busywaiting</li> <li><pre class="shiki vesper" style="background-color:#101010;color:#FFF"><code><span class="line"><span style="color:#A0A0A0"> function</span><span style="color:#FFC799"> syncSleep</span><span style="color:#FFF">() {</span></span>
<span class="line"><span style="color:#A0A0A0">  let</span><span style="color:#FFF"> a </span><span style="color:#A0A0A0">=</span><span style="color:#FFC799"> 1</span><span style="color:#FFF">;</span></span>
<span class="line"><span style="color:#A0A0A0">  for</span><span style="color:#FFF">(</span><span style="color:#A0A0A0">let</span><span style="color:#FFF"> i</span><span style="color:#A0A0A0">=</span><span style="color:#FFC799">0</span><span style="color:#FFF">;i</span><span style="color:#A0A0A0">&lt;</span><span style="color:#FFC799">10000000</span><span style="color:#FFF">;i</span><span style="color:#A0A0A0">++</span><span style="color:#FFF">) {</span></span>
<span class="line"><span style="color:#FFF">  a</span><span style="color:#A0A0A0">++</span><span style="color:#FFF">;</span></span>
<span class="line"><span style="color:#FFF">  }</span></span>
<span class="line"><span style="color:#FFF">}</span></span>
<span class="line"><span style="color:#FFF"> </span></span>
<span class="line"><span style="color:#FFC799"> syncSleep</span><span style="color:#FFF">();</span></span></code></pre></li> <li>we can defer the execution of this , by delaying it for some time.</li> <li>what are the common async functions ? <ul><li><code>setTimeout()</code></li> <li><code>fs.readFile</code> to read a file from your filesystem <ul><li>async , because can’t read a file immediately</li> <li>can take some time to access the file</li> <li>other process might be executing it</li> <li>you yourself might be editing it</li> <li>when done reading , it will call a callback to us</li></ul></li></ul></li> <li><code>fetch</code> to fetch some data from an API endpoint <ul><li>async call -> getting data from someone’s elses server.</li></ul></li></ul></li> <li><p>the console.log after <code>fs.readFile</code> is executed function, cause accessing the file takes time, and <code>fs.readFile</code> is anyway asynchronous</p> <ul><li>and since it is expensive and async, we proceed do our own thing.</li></ul></li> <li><p>Real world use of callbacks</p></li> <li><p>JS  Architecture in the Browser</p> <ul><li>check this out : <a href="http://latentflip.com/loupe/" rel="nofollow">http://latentflip.com/loupe/</a></li> <li>call stack where your code gets places if its synchronous</li> <li>callback queue <ul><li>when we become idle, the event loop finally runs</li> <li>checks if something there in the callback queue or not and then puts it in the callstack</li></ul></li> <li>every line of reaching there, is reaching the callstack -> what is being put on the stack to run that. <ul><li>only one thing put at a time if all of our code is synchronous.</li> <li>otherwise , the asynchronous code is not put there</li> <li>when the loop finally exists, the stack can be popped.</li> <li>if we only have synchronous code, all the code is placed on the call stack.</li></ul></li> <li>for async code: <ul><li>events pushed to callback queue, until the thread is busy.</li> <li>it will be kept waiting, when the call stack is empty, the callback queue will then put the event back into the callback queue.</li> <li>if there is some async task that is completed, it gets pulled from callback queue to the call stack.</li></ul></li></ul></li> <li><p>Promises</p> <ul><li>How can we create an asynchronous function of our own ?</li> <li>usually all async function that well write will be on top of JS provided async functions like <code>setTimeout</code> of <code>fs.readFile</code></li> <li>leaner way to write it is to use promises than callbacks.</li> <li>rather than user giving a callback to the next one, we use the <code>.then</code> method on the promise to resolve it after it has been successful.</li> <li>the data of the promise comes asynchronously when loading the <code>.then</code> is called  to know where to send the data. <ul><li>to know the next party knows that the data is here.</li></ul></li> <li>Promise is just like a class -like Date class. <ul><li><p>when we initialize it , we have to give the first argument as function and the argument is the resolve argument.</p></li> <li><pre class="shiki vesper" style="background-color:#101010;color:#FFF"><code><span class="line"><span style="color:#A0A0A0">var</span><span style="color:#FFF"> d </span><span style="color:#A0A0A0">=</span><span style="color:#A0A0A0"> new</span><span style="color:#FFC799"> Promise</span><span style="color:#FFF">(</span><span style="color:#A0A0A0">function</span><span style="color:#FFF">(onDone){</span></span>
<span class="line"><span style="color:#FFC799">resolve</span><span style="color:#FFF">(</span><span style="color:#99FFE4">"some data"</span><span style="color:#FFF">);</span></span>
<span class="line"><span style="color:#FFF">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A0A0A0">function</span><span style="color:#FFC799"> callback</span><span style="color:#FFF">() {</span></span>
<span class="line"><span style="color:#FFF">console.</span><span style="color:#FFC799">log</span><span style="color:#FFF">(d);</span></span>
<span class="line"><span style="color:#FFF">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FFF">d.</span><span style="color:#FFC799">then</span><span style="color:#FFF">(callback);</span></span></code></pre></li> <li><p>Promise can have 3 states possible -><code>Pending</code>, <code>Resolved</code> ,<code>Rejected</code>.</p></li> <li><p><code>.then()</code> method called on this promise when it is being resolves.</p></li> <li><p>Just a class introduced to cleanup callbacks and to write async way.</p></li></ul></li></ul></li> <li><p>Async Await</p> <ul><li>Much more cleaner way</li> <li>Syntactic sugar , under the hood still using callbacks.</li></ul> <pre class="shiki vesper" style="background-color:#101010;color:#FFF"><code><span class="line"><span style="color:#A0A0A0">function</span><span style="color:#FFC799"> sagniksAsyncFunction</span><span style="color:#FFF">() {</span></span>
<span class="line"><span style="color:#A0A0A0">let</span><span style="color:#FFF"> p </span><span style="color:#A0A0A0">=</span><span style="color:#A0A0A0"> new</span><span style="color:#FFC799"> Promise</span><span style="color:#FFF">(</span><span style="color:#A0A0A0">function</span><span style="color:#FFF">(resolve) </span><span style="color:#A0A0A0">=></span><span style="color:#FFF"> {</span></span>
<span class="line"><span style="color:#FFC799">resolve</span><span style="color:#FFF">(</span><span style="color:#99FFE4">"hi there"</span><span style="color:#FFF">)};</span></span>
<span class="line"><span style="color:#FFF">return p;</span></span>
<span class="line"><span style="color:#FFF">)};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A0A0A0">async</span><span style="color:#A0A0A0"> function</span><span style="color:#FFC799"> main</span><span style="color:#FFF">() {</span></span>
<span class="line"><span style="color:#A0A0A0">	const</span><span style="color:#FFF"> value </span><span style="color:#A0A0A0">=</span><span style="color:#FFF"> awit </span><span style="color:#FFC799">sagniksAsyncFunction</span><span style="color:#FFF">(); </span></span>
<span class="line"><span style="color:#FFF">	console.</span><span style="color:#FFC799">log</span><span style="color:#FFF">(value);</span></span>
<span class="line"><span style="color:#FFF">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A0A0A0">await</span><span style="color:#FFC799"> main</span><span style="color:#FFF">();</span></span></code></pre> <ul><li>2 keywords and removes the use of all the <code>.then</code> syntax and no callbacks syntax is required any more.</li> <li>This control will not go beyond the log.</li> <li>Under the hood it is the same exact logic and the thread is not blocked, it will just queue the async tasks.</li></ul></li> <li><p>Map,Filter and Arrow Functions:</p> <ul><li>Map, filter are helper functions when it comes to arrays. <ul><li>map <ul><li>define the transformation that we need to do in a function is added in the function</li> <li>map is a global function , on the array class, whose first function is a callback and then maps that number with the result.</li> <li>maps the result with a initial input with a transformation function and maps to a new result in memory.</li></ul></li> <li>filter <ul><li>it filters an array based on some predicate on the array class.</li> <li>makes the syntax slightly cleaner.</li></ul></li></ul></li> <li>Arrow functions are another way to write functions in JS. <ul><li>arrow functions and normal functions are almost same, except when used in callbacks, when it can change.</li> <li>there is a difference in the bindiung of normal functions and arrow functions.</li></ul></li></ul></li></ul>`);
      },
      $$slots: { default: true }
    }
  ]));
}
const __vite_glob_0_0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: JS_Fundamentals_md,
  metadata
}, Symbol.toStringTag, { value: "Module" }));
export {
  __vite_glob_0_0 as _
};
