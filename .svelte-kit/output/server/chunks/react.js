import { G as sanitize_props, J as spread_props } from "./index.js";
import { M as MarkdownLayout } from "./MarkdownLayout.js";
const metadata = {
  "title": "React",
  "tags": ["react", "100xdevs", "frontend"],
  "date": "1/22/26"
};
const { title, tags, date } = metadata;
function React_md($$renderer, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  MarkdownLayout($$renderer, spread_props([
    $$sanitized_props,
    metadata,
    {
      children: ($$renderer2) => {
        $$renderer2.push(`<h3>before react</h3> <ul><li>why was react written a certain way</li> <li>generating the foundations for react</li> <li>makes the process easier to learn harder concepts down the line</li> <li>internet has static and dynamic websites <ul><li>more things get appended to the bottom</li> <li>the html that we got back from the server initially is slowly getting appended</li> <li>through DOM manipulation are people able to create websites -> before React</li> <li>as they scroll and add more posts , append new posts, DOM manipulation , updating things on the DOM ,without us hard refreshing the page</li> <li>all of this HTML being injected in the DOM via javascript</li> <li>update the DOM when we clicked on the button</li></ul></li> <li>DOM manipulation is very hard to write as a developer, Making dynamic websites, with the primitives that DOM provides us is very hard. <ul><li>thats why react came into the picture.</li> <li><code>document.createElement</code></li> <li><code>document.appendChild</code></li> <li><code>document.setAttribute</code></li> <li><code>element.children</code></li></ul></li> <li>adding title, description , followed by a button and we add a method addTodo to do onclick handler.</li> <li>ugly approach on updating : <ul><li>add the whole HTML in the innerHTML tag and fit in that</li></ul> <pre class="shiki vesper" style="background-color:#101010;color:#FFF"><code><span class="line"><span style="color:#FFF">document.</span><span style="color:#FFC799">getElementElementById</span><span style="color:#FFF">(</span><span style="color:#99FFE4">'container'</span><span style="color:#FFF">).innerHTML </span><span style="color:#A0A0A0">=</span><span style="color:#99FFE4"> \`</span></span>
<span class="line"><span style="color:#99FFE4">&lt;div></span></span>
<span class="line"><span style="color:#99FFE4">	&lt;div>\${</span><span style="color:#FFF">title</span><span style="color:#99FFE4">}&lt;/div></span></span>
<span class="line"><span style="color:#99FFE4">	&lt;div>\${</span><span style="color:#FFF">description</span><span style="color:#99FFE4">}&lt;/div></span></span>
<span class="line"><span style="color:#99FFE4">	&lt;button>Mark as Done&lt;/button></span></span>
<span class="line"><span style="color:#99FFE4">&lt;/div>\`</span><span style="color:#FFF">;</span></span></code></pre> <ul><li>appendChild -> add this item as a child on the DOM Tree</li></ul></li> <li>instead of manually updating it by setting <code>innerHTML</code>, its better to set the items using by first setting an outerDiv and then adding elements to it.</li> <li>the goals is to create something in memory and then eventually put them in DOM.</li> <li><code>setAttribute</code> lets us sets attributes on a specific tag.</li> <li>Problem with this approach till now: <ul><li>very hard to add and remove elements , no central state !</li> <li>what if there is a server where these todos are put</li> <li>what if we update a TODO from a mobile app, and get a new array of todos on the frontend, how will we update the DOM then ?</li> <li>We only have a <code>addTodo</code> function , we dont have a <code>updateTodo</code> or <code>removeTodo</code> function yet !</li></ul></li> <li>If we can write a function that takes state as an input and creates the output on right, much more powerful than our original approach.</li> <li>DOM Manipulation is the only way to create dynamic websites <ul><li>making it very hard for even writing a simple website</li> <li>even react under the hood interacts with DOM to make websites.</li></ul></li> <li>the next objective is to given a state , we can render the state on the DOM.</li> <li>what we want ideally is to build a diff and only apply the diff to the DOM instead of clearing the screen and building it again. <ul><li>dont clear the DOM upfront, update it based on what has changed.</li> <li>Question is, how does it calculate what all has changed ?</li> <li>Has a TODO been marked as complete ?</li> <li>Has a TODO been removed from the backend ?</li> <li>Hint: Remembering / keeping track of the old todos in a variable (virtual DOM)</li></ul></li> <li>In the real world, given a set of dynamic TODOs, we would have to render and re-render the latest data and update the DOM accordingly. <ul><li>given a state whatever we want on the screen , we need to update the DOM accordingly.</li> <li>![[Screenshot 2026-01-26 at 8.03.17 PM.png]]</li></ul></li> <li>Better way to update the DOM(according to what React does): <ul><li>Dont clear the DOM upfront, update it based on what has changed.</li> <li>Question is, how does it calculate what all has changed ? <ul><li>Has a todo been marked as complete ?</li> <li>Has a todo been removed from the backend ?</li></ul></li> <li>You calculate the difference <ul><li>based on the diff, calculate the diff and its a slightly better way of solving the same problem.</li></ul></li> <li>We remember the old todos in a variable -> Virtual DOM <ul><li>Place where they have a storage of the DOM.</li></ul></li></ul></li></ul> <h3>react</h3> <ul><li>what is the easiest way to create a dynamic frontend website ? <ul><li>update a state variable <ul><li>general developer logic</li></ul></li> <li>delegate the task of figuring out the diff to a hefty function <ul><li>react core library</li></ul></li> <li>tell the hefty function how to add, update and remove elements. <ul><li>react dom</li> <li>react native</li></ul></li></ul></li> <li>react takes care of re-rendering the whole thing and figuring out what to print and what to update. <ul><li>our code is pretty lean and we dont have to update the changes here.</li></ul></li> <li>react dom , react native etc. exposes the functionalities to react, whereas react is a diff calculating framework that calculates the things to be put on the DOM.</li> <li>virtual dom and real dom the changes are not propogated immediately <ul><li>react does a bunch of optimizations and does a bunch call</li> <li>batching the changes helps in performance</li></ul></li></ul> <h3>diving deep into react:</h3> <ul><li><p>jargon to learn</p> <ul><li>jsx</li> <li>class vs classname</li> <li>static vs dynamic websites</li> <li>state</li> <li>components</li> <li>re-rendering</li></ul></li> <li><p>why do we need react ?</p> <ul><li>for static websites, you don’t</li> <li>dont need for dynamic websites - can do in HTML,CSS and JS.</li> <li>the contents of the page are changing , when we are changing the press buttons.</li> <li>For dynamic websites, these libraries makes us life easier to do DOM Manipulation.</li></ul></li> <li><p>react is just an easier way to write normal HTML/CSS/JS.</p></li> <li><p>Its a new syntax, that under the hood gets converted to HTML/CSS/JS.</p></li> <li><p>People realized that its harder to do DOM manipulation the conventional way.</p></li> <li><p>new syntax to write frontends.</p></li> <li><p>how react makes this better at writing frontends?</p> <ul><li>For creating react app, we only need to usually worry about 2 things <ul><li>State <ul><li>An object that represents the current state of the application.</li> <li>It represents the dynamic things in our app (things that change)</li> <li>Eg: the value of the counter b</li></ul></li> <li>Components <ul><li>things that can be reused in our application and used throughout</li> <li>how a DOM element should render, given a state.</li> <li>Eg: counter button itself</li> <li>Eg: Button is a component that takes the state(currentCount) as an input and is supposed to render it accordingly.</li></ul></li></ul></li></ul></li> <li><p>We usually have to define all of our components once , and then all we have to do is to update the state of our application, React will take care of re-rendering the application.</p></li> <li><p>![[Screenshot 2026-01-27 at 6.52.32 PM.png]]</p></li> <li><p>a state change renders a re-render.</p> <ul><li>effectively the function takes a global state and does a re-render of the thing.</li> <li>the function takes a state as an input and spits a state as an output.</li></ul></li></ul> <h3>todo app:</h3> <ul><li>in useState is the initial state value.</li> <li>count and setCount are the two state variables that store the value for the same.</li> <li><code>App()</code> is our first component.</li> <li>npm run build will generate a static build of all the code <ul><li>similar to the JS browser / target based code it will generate</li> <li>we can directly serve it .</li></ul></li> <li>when we want to render a JS variable in JSX we have to wrap it in <code>{}</code> braces.</li> <li>in onClickHandler dont have to call the function , just give the function name and react under the hood knows that we need to call this function.</li> <li>react will automatically know when to update the state and given an state it will reconcile into a state it gets the value updated.</li> <li>we give it state and component, and any time the state updates, the component should re-render. <ul><li>because react does not look at every variable as a state variable.</li> <li>if we have to define a state variable then we have to do it a certain way.</li> <li>using useState() hook to define our state, and if we define the state , we can update it.</li></ul></li> <li><code>const [count,setCount] = useState(0);</code> <ul><li>the first value put it in count and the second value put it in setCount.</li> <li>setCount when called , it calls another function that dispatches and re-renders the thing here.</li></ul></li> <li>the right way to use state variables, is that it gave a state variable and with that given value is to call the value. <ul><li>so any time onClickHandler is called , we have to set the state and react re-renders the thing similar to the thing on button press.</li></ul></li> <li>we pass inputs to an custom component is through something called <code>props</code>. <ul><li>can create multiple children components and the parent components call pass the values and render it there.</li> <li>can access them using props.obj_name and props.user_name</li> <li>can reuse the component again and again</li></ul></li> <li>high-level we have defined our own application and reused it.</li> <li><code>setTodos([...todos,{...</code> spreads out all the todos and sets all the values from the array here <ul><li>we want all the original todos and this new todo at the end.</li> <li>can add more items to the state and react takes care of handling of how to add the items to the todos.</li></ul></li> <li>while iterating over the list of objects, react to render would require a key property so that it is unique.</li> <li>Any time a parent re-renders , its child re-renders as well.</li> <li>to put any css , we put it as an object with 2 curly braces.</li></ul> <pre class="shiki vesper" style="background-color:#101010;color:#FFF"><code><span class="line"><span style="color:#A0A0A0">&lt;</span><span style="color:#FFC799">button</span><span style="color:#A0A0A0"> style={</span><span style="color:#FFF">{}</span><span style="color:#A0A0A0">}>&lt;/</span><span style="color:#FFC799">button</span><span style="color:#A0A0A0">></span></span></code></pre> <ul><li>todos is a state which is being passed as a component. <ul><li>we can pass todos which is a state variable , compared to the new component.</li></ul></li> <li>vite is one of many ways to bootstrap and bundler to build a react app, others also exist. <ul><li>many such frameworks , to bootstrap our application, watching files, bundling files etc.</li></ul></li></ul> <h3>React Deeper Dive :</h3> <h4>React returns</h4> <ul><li>reach component can return a single top-level xml</li> <li>Why? <ul><li>makes it easier to do reconciliation</li> <li>jsx expressions should have one parent div</li> <li>cannot return an xml that doesnt have a top level parent div</li> <li>can instead of extra div , we can also add a empty fragment or a React.Fragment.</li></ul></li> <li>react -> dynamic website <ul><li>the content changes very quickly</li> <li>react is the easy way to create this</li> <li>create, update and upload anything on the dom is a good way to re-render</li> <li>whenever the dom updates happen, is called a re-render.</li> <li>in react, we want to minimize the re-renders</li></ul></li> <li>need to add optimizations to reduce the number of re-renders to make it performant.</li></ul> <h4>re-rendering</h4> <ul><li>a re-render means that <ul><li>react did some work to calculate what all should update in this component.</li> <li>the component actually gets called (we can put a logger to confirm this)</li> <li>the inspector shows us a bounding box around the component</li></ul></li> <li>it happens when <ul><li>a state variable that is being used inside a component changes</li> <li>a parent component re-renders triggers all children re-rendering</li></ul></li> <li>2 ways of keeping the re-rendering less: <ul><li>pushing the state down</li> <li>react.memo knows the title has not changed, so we dont need to change it.</li></ul></li> <li>wrapping a component inside react.memo will make it only change it when it has a dynamic state change , not only when there are static changes.</li> <li>react has a exact copy of the DOM somewhere else and many times we change the state variable - it creates a new diff ,and based on the diff it decides what it needs to do - like create, update or delete element.</li> <li>always push state from parent to child.</li></ul> <h4>key</h4> <ul><li>each child in a list should have a unique prop.</li> <li>thats the way the diffing engine will keep track of changes that have formed.</li> <li>key tells react to make the correct updates to the dom and keep track of the changes.</li></ul> <h4>wrapper components</h4> <ul><li>you can create an meta component, that takes the inner component as an onput.</li> <li>not necessary that the component always has to take state as an input.</li> <li>whenever we make a component, inside which we pass children, inside that we get access to the whole thing in the children component, inside the variable.</li> <li>the structure of the outer thing and inside this what others can write inside this</li> <li>using that we can reach the final state of what inside can be written inside it.</li></ul> <h3>hooks:</h3> <ul><li>until now we have discussed useState.</li> <li>these functions that start with use are called as hooks.</li> <li>hooks in react are functions that allow us to hook into react state and lifecycle features from function components.</li> <li>other examples of hooks: <ul><li>useEffect</li> <li>useMemo</li> <li>useCallback</li> <li>useRef</li> <li>useReducer</li> <li>useContext</li> <li>useLayoutEffect</li></ul></li> <li>lifecycle features: <ul><li>earlier react used to be written in a different way. <ul><li>we got access to lifecycle functions</li></ul></li> <li>before functional components, we had class based components</li> <li><code>onComponentMount</code> and <code>onComponentUnmount</code> would be two methods associated with it and it will be used to hook onto it.</li> <li>bunch of the lifecycle functions , it re-renders</li> <li>used to be the way in class based components</li></ul></li> <li>harder to do it functional components, so hooks were introduced.</li> <li>some jargon: <ul><li>side effects <ul><li>the operations can affect other components, interact with browser or do asynchronous changes.</li> <li>in react, we have functional components and anything not related to rendering , etc. are considered part of side effects as they are not part of the main react rendering cycle.</li> <li>eg: fetching data from the backend</li> <li>this asynchronous call can be called as a side effect to the codebase</li> <li>these need to be seperate from our rendering cycle.</li> <li>eg: setTimeout , fetch, setInterval</li> <li>shouldnt necessarily collude with the rendering cycle</li></ul></li> <li>hooks <ul><li>went part of react for the longest time</li> <li>allows us to use many state management techniques without explicitly calling lifecycle events.</li> <li>they enable functional components to have access to stateful logic and lifecycle features, which were previously only possible in class components.</li> <li>This has lead to a more concise and readable way of writing components in React.</li></ul></li></ul></li></ul> <h5>useState</h5> <ul><li>lets us describe the state of our application</li> <li>whenever state updates, it will trigger a re-render which will finally result in a DOM update.</li> <li>the problem comes when we have to do some other side effect or hit a backend api etc. which we can’t do with the useState.</li></ul> <h5>useEffect</h5> <ul><li>allows us to do lifecycle event</li> <li>allows us to do things when component is mounted</li> <li>when the component gets put into the dom , is called a mount</li> <li>some things should run when this element is being put there</li> <li>that is the use of the <code>onComponentMount</code></li> <li>similarly we would have an action when the things need to be unmounted.</li> <li>useEffect lets us hook onto it.</li> <li>we are only sending one request when the component mounts</li></ul> <pre class="shiki vesper" style="background-color:#101010;color:#FFF"><code><span class="line"><span style="color:#A0A0A0">const</span><span style="color:#FFF"> [todos,setTodos] </span><span style="color:#A0A0A0">=</span><span style="color:#FFC799"> useState</span><span style="color:#FFF">([]);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FFC799">useEffect</span><span style="color:#FFF">(() </span><span style="color:#A0A0A0">=></span><span style="color:#FFF"> {</span></span>
<span class="line"><span style="color:#FFC799">fetch</span><span style="color:#FFF">(url).</span><span style="color:#FFC799">then</span><span style="color:#FFF">(</span><span style="color:#A0A0A0">async</span><span style="color:#FFF"> (res) </span><span style="color:#A0A0A0">=></span><span style="color:#FFF"> {</span></span>
<span class="line"><span style="color:#A0A0A0">const</span><span style="color:#FFF"> json </span><span style="color:#A0A0A0">=</span><span style="color:#A0A0A0"> await</span><span style="color:#FFF"> res.</span><span style="color:#FFC799">json</span><span style="color:#FFF">();</span></span>
<span class="line"><span style="color:#FFF">setTodos[json]})},[]);</span></span></code></pre> <ul><li>for making async useEffect , use the library useAsyncEffect or capsulate it inside another async function.</li> <li>useEffect hook serves the same purpose as <code>componentDidMount</code> and <code>componentDidUpdate</code> and <code>componentWillUnmount</code> in react class components, but unified into a single API.</li> <li>when the thing renders for the first time, the code will run and never will it run again , only the first time the component is mounted <ul><li>thats why a popular hook to do some actions under some conditions.</li></ul></li> <li>the dependency array at the end, tells when should the callback fn has to be run. <ul><li>it takes state variables as input and any time the state variable changes , it will run the callback fn.</li> <li>want to run a certain logic when the state variable changes.</li></ul></li> <li>axios is very big and only getting get function. <ul><li>using tree shaking , the final library would only get that library in the final build.</li></ul></li> <li>arrow functions vs normal functions <ul><li>only matters  when require to use  bind and this in functions</li></ul></li> <li></li></ul> <h5>useMemo</h5> <ul><li><p>memo means remembering some output given an input and not computing it again.</p> <ul><li>like caching.</li> <li>have this cached value, dont recompute the result again.</li></ul></li> <li><p>eg: lets say you are a f1 driver and want to check how much petrol is left. Would u do that in every lap ? Would you do that every 10 laps ? or every 20 mins ?</p></li> <li><p>eg2: create an app that does 2 things:</p> <ul><li>increase a counter by 1</li> <li>lets user put a value in an input box (n) and we need to show sum from 1-n</li> <li>restriction: everything needs to inside App</li></ul></li> <li><p>when we click on the button, it re-runs the expensive operation again of summing value and cant we just remember the value from the last and keep the sum intact.</p> <ul><li>across values if you want to remember the values in state variable, we would use useMemo.</li> <li>an ugly way to do this would be via useEffect , where any time a loop is running we would take the value and store the result somewhere</li> <li>the problem is to use a unneccesaray re-render</li></ul> <pre class="shiki vesper" style="background-color:#101010;color:#FFF"><code><span class="line"><span style="color:#A0A0A0">const</span><span style="color:#FFF"> [counter,setCounter] </span><span style="color:#A0A0A0">=</span><span style="color:#FFC799"> useState</span><span style="color:#FFF">(</span><span style="color:#FFC799">0</span><span style="color:#FFF">);</span></span>
<span class="line"><span style="color:#A0A0A0">const</span><span style="color:#FFF"> [inputValue,setInputValue] </span><span style="color:#A0A0A0">=</span><span style="color:#FFC799"> useState</span><span style="color:#FFF">(</span><span style="color:#FFC799">1</span><span style="color:#FFF">);</span></span>
<span class="line"><span style="color:#A0A0A0">const</span><span style="color:#FFF"> [finalValue,setFinalValue] </span><span style="color:#A0A0A0">=</span><span style="color:#FFC799"> useState</span><span style="color:#FFF">(</span><span style="color:#FFC799">0</span><span style="color:#FFF">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FFC799">useEffect</span><span style="color:#FFF">(() </span><span style="color:#A0A0A0">=></span><span style="color:#FFF"> {</span></span>
<span class="line"><span style="color:#A0A0A0">let</span><span style="color:#FFF"> count </span><span style="color:#A0A0A0">=</span><span style="color:#FFC799"> 0</span><span style="color:#FFF">;</span></span>
<span class="line"><span style="color:#A0A0A0">for</span><span style="color:#FFF">(</span><span style="color:#A0A0A0">let</span><span style="color:#FFF"> i</span><span style="color:#A0A0A0">=</span><span style="color:#FFC799">1</span><span style="color:#FFF">;i</span><span style="color:#A0A0A0">&lt;=</span><span style="color:#FFF"> inputValue;i</span><span style="color:#A0A0A0">++</span><span style="color:#FFF">){</span></span>
<span class="line"><span style="color:#FFF">count </span><span style="color:#A0A0A0">+=</span><span style="color:#FFC799"> 1</span><span style="color:#FFF">;</span></span>
<span class="line"><span style="color:#FFF">}</span></span>
<span class="line"><span style="color:#FFF">},inputValue);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A0A0A0">return</span><span style="color:#A0A0A0"> &lt;</span><span style="color:#FFC799">div</span><span style="color:#A0A0A0">></span></span>
<span class="line"><span style="color:#A0A0A0">&lt;</span><span style="color:#FFC799">input</span><span style="color:#A0A0A0"> onChange={</span><span style="color:#FFF">(e) </span><span style="color:#A0A0A0">=></span><span style="color:#FFC799"> setInputValue</span><span style="color:#FFF">(e.target.value)</span><span style="color:#A0A0A0">}</span><span style="color:#A0A0A0"> placeholder={</span><span style="color:#99FFE4">"Find the sum from 1 to n"</span><span style="color:#A0A0A0">}></span></span>
<span class="line"><span style="color:#A0A0A0">&lt;</span><span style="color:#FFC799">br</span><span style="color:#A0A0A0"> /></span></span>
<span class="line"><span style="color:#FFF">Sum from 1 to </span><span style="color:#A0A0A0">{</span><span style="color:#FFF">inputValue</span><span style="color:#A0A0A0">}</span><span style="color:#FFF"> is </span><span style="color:#A0A0A0">{</span><span style="color:#FFF">finalValue</span><span style="color:#A0A0A0">}</span></span>
<span class="line"><span style="color:#A0A0A0">&lt;</span><span style="color:#FFC799">br</span><span style="color:#A0A0A0"> /></span></span>
<span class="line"><span style="color:#A0A0A0">&lt;</span><span style="color:#FFC799">button</span><span style="color:#A0A0A0"> onClick={</span><span style="color:#FFF">() </span><span style="color:#A0A0A0">=></span><span style="color:#FFC799"> setCounter</span><span style="color:#FFF">(counter</span><span style="color:#A0A0A0">+</span><span style="color:#FFC799">1</span><span style="color:#FFF">)</span><span style="color:#A0A0A0">></span><span style="color:#FFC799">Counter</span><span style="color:#FFF"> ({counter}) </span><span style="color:#A0A0A0">&lt;/</span><span style="color:#FFF">button</span><span style="color:#A0A0A0">></span></span>
<span class="line"><span style="color:#A0A0A0">&lt;/</span><span style="color:#FFF">div</span><span style="color:#A0A0A0">></span></span></code></pre></li> <li><p>we are updating the state variable , which will cause 2 re-renders.</p></li> <li><p>a better approach would be to run all the counter logic only when some value changes and not we recomputing the same thing again and again.</p></li></ul> <h5>useCallback</h5> <ul><li>memo lets us skip re-rendering a component when its props are unchanged. <ul><li>if we wrap the child inside a memo, it will only re-render if the inputs to the child have changed.</li></ul></li> <li>basically if you ever want to memoize a function, we use useCallback.</li> <li>useCallback is about not rendering a child, if the function doesnt need to change across renders.</li></ul> <h5>useRef</h5> <ul><li>you want to overwrite what the state library has written over the screen</li></ul> <h5>useContext</h5> <ul><li>ref from react.dev</li></ul> <h4>custom hooks</h4> <ul><li>hooks that we can create on our own and use it</li> <li>can create custom hooks for others to use</li> <li>must start with <code>use</code> primitive <ul><li>can contain other hooks inside it</li></ul></li> <li>the thing inside a hook must be another hook or a component.</li></ul> <h3>prop drilling:</h3> <ul><li>how do you think one should manage state ? <ul><li>keep everything in the top level component or</li> <li>keep everything as low as possible (at the Least Common Ancestor of children that need a state)</li></ul></li> <li>the idea is to keep things at the low level component</li> <li>should try to push down state as much as possible. <ul><li>so that other states dont need to re-render as much as possible.</li></ul></li> <li>store at the least common ancestor.</li> <li>push it down as much as possible.</li> <li>we are drilling down the props.</li> <li>if there are components <ul><li>![[Screenshot 2026-02-15 at 8.20.34 AM.png]]</li> <li>if c1 has props, c2,c3 doesnt, they still need to pass it down the props , so that c4 can get it.</li></ul></li> <li>if there is a state variable, that needs to be used,it should be in their lowest ancestor, we are just passing it down. <ul><li>this is what is called as prop drilling .</li> <li>anti-pattern because how unmanageable it makes the code.</li> <li>it is unappealing because how visually unappealing it makes the code look like at.</li></ul></li> <li>Prop drilling doesnt mean that the parent re-renders children, it just means the syntactic uneasiness when writing code.</li></ul> <h3>routing in react:</h3> <ul><li>react-router-dom</li> <li>two simple ways to directly switch <ul><li><code>window.locaton.href=path-name</code></li> <li>global location object we have access to in the DOM</li> <li>but this we refetch the page everytime</li></ul></li> <li>better to use <code>useNavigate()</code> hook so as to not take hard render of it. <ul><li>need to use inside a component</li></ul></li> <li>lazy loading <ul><li>rn , a complete bundle comes back all at once <ul><li>the problem is , the person will just come to landing page , all the bundle will come back all at once , which is not required, if the person is just in the dashboard.</li> <li>the person should only receive the code for the given bundle the require - only give them a small bundle</li> <li>incremently giving them the website than giving the whole web page</li></ul></li> <li>react-router allows us to to do lazy loading and incrementally allows us to give the pages as required.</li> <li>they will lazily load the more page components , on the page they are not currently on.</li> <li>navigate wont fetch the data from backend , we do a fetch call from inside the component that we want to hit the backend APIs.</li> <li>Suspense API <ul><li>async data fetching wrapper</li> <li>for async components and not have access to them immediately , we wrap it under a suspense API - depends on internet connection</li> <li>for cases like this, react provides the suspense API.</li> <li>wrapper the component to be rendered inside suspense, makes it that we have a mildly more client side optimized application.</li></ul></li> <li>the only thing here is we have to wrap this under a suspense.</li></ul></li></ul> <h3>Context API</h3> <ul><li>lets us fix prop drilling</li> <li>it makes us very easy to pass state components, without drilling it down.</li> <li>“teleport” data to the components in the tree that need it without passing it down the prop chain.</li> <li>if we are using the context api, we are pushing our state management outside the core react components.</li> <li><code>reducer/useReducer()</code> hook <ul><li>basics of state management in react without using a library</li></ul></li></ul>`);
      },
      $$slots: { default: true }
    }
  ]));
}
const __vite_glob_0_7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: React_md,
  metadata
}, Symbol.toStringTag, { value: "Module" }));
export {
  __vite_glob_0_7 as _
};
